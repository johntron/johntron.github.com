<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: hacking | Johntron.com]]></title>
  <link href="http://johntron.github.com/blog/categories/hacking/atom.xml" rel="self"/>
  <link href="http://johntron.github.com/"/>
  <updated>2013-01-31T08:10:55-06:00</updated>
  <id>http://johntron.github.com/</id>
  <author>
    <name><![CDATA[John Syrinek]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ubuntu 12 boot process explained]]></title>
    <link href="http://johntron.github.com/hacking/ubuntu-12-boot-process-explained/"/>
    <updated>2013-01-06T00:00:00-06:00</updated>
    <id>http://johntron.github.com/hacking/ubuntu-12-boot-process-explained</id>
    <content type="html"><![CDATA[<p>I’ve been trying to convert my existing Ubuntu 12.04 server (running this website) to RAID1 for various reasons. Throughout the process, I’ve learned a ton about the Linux boot process (aka “bootstrapping”), and realized a high-level explanation would really help other developers like myself. What follows is a starting place for anyone trying to recover a Linux system or do something other than a default install – the nitty gritty can be found elsewhere.</p>

<h3><a href="http://www.ibm.com/developerworks/library/l-linuxboot/index.html"><img class="alignnone size-full wp-image-787" alt="Linux boot process" src="http://johntron.com/wp-content/uploads/2013/01/fig1.gif" width="529" height="300" /></a></h3>

<h3>Step 1: hardware to software</h3>

<p>This first step is the part that seems like magic to a lot of people, possibly because it’s something that “just happens” and is very difficult to debug when things go wrong due to a general lack of information. Once power is applied, a motherboard initializes a Basic Input/Output System (BIOS). The BIOS performs some basic tests of the hardware (POST), then looks to the boot device (usually a hard drive) with the highest priority to see what to do next.</p>

<p>Please note, newer hardware uses something called the Unified Extensible Firmware Interface. I will not be covering UEFI, but some crucial information is included below.</p>

<h3>Step 2: BIOS to bootloader</h3>

<p>The BIOS’s ultimate goal is to transfer control to some higher-level system. The BIOS looks at the beginning of devices (highest-priority first) until it finds a <a href="http://en.wikipedia.org/wiki/Master_boot_record" target="_blank">Master Boot Record</a> (MBR) and attempts to launch any bootloader it finds. Unfortunately, for historical reasons the MBR is very small and GRUB doesn’t fit into such a small space. For this reason, GRUB places <a href="http://www.gnu.org/software/grub/manual/grub.html#Images" target="_blank">boot.img</a> in the MBR which simply jumps to  the location on disk immediately after the MBR (called the post-MBR gap) from which the rest of GRUB (<a href="http://www.gnu.org/software/grub/manual/grub.html#Images" target="_blank">core.img</a>) is loaded. At this point we are presented with the GRUB menu.</p>

<h3>Step 3: Bootloader to kernel</h3>

<p>Once GRUB is up and running it decompresses and loads the Linux kernel from the path specified by the <em>linux</em> command – typically /vmlinuz or some variation. The kernel is able to (eventually) get us a <a href="http://en.wikipedia.org/wiki/User_space" target="_blank">user space</a> to do the things we really care about, but we’re not quite done with GRUB.</p>

<p>The Linux kernel is responsible for initializing devices and preparing the system for use by the OS. A kernel that supports every device out there would necessarily be massive. To keep the kernel small and platform agnostic, a pluggable architecture is used. The kernel can load other modules to accomplish its goals. So where are these modules located? In a compressed archive called initramfs! So where is initramfs? Ubuntu 12.10 relies on GRUB to inject initramfs into the kernel (see <a href="http://www.gnu.org/software/grub/manual/html_node/initrd.html" target="_blank">initrd</a>). This approach uses the kernel’s (deprecated) initrd system (see “<a href="https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt" target="_blank">External initramfs images</a>“). So the /initrd.img is named like an initrd archive, but it’s really a initramfs archive.</p>

<h3>Step 4: kernel to init</h3>

<p>Now that the kernel is up and running and has access to any modules it might need, it sets up core components of the system then transfers control to the first userspace process, <em>/init</em> (located in initramfs). <em>/init</em> is simply a shell script that overwrites the temporary filesystem mounted by the kernel with the root filesystem used by the OS. The last action taken by <em>/init</em> (the shell script) is to launch the init (the daemon). The init daemon is located at <em>/sbin/init</em> on Ubuntu and acts as the direct- or indirect-parent process of all other processes. Ubuntu uses its own version of init referred to as <a href="http://upstart.ubuntu.com/" target="_blank">upstart</a>. In addition to acting as a primordial ancestor, upstart also launches Ubuntu services configured to start at boot, kills services when necessary, and supervises them while they’re running. If you’ve ever used the <em>service</em> command or edited anything under <em>/etc/init.d</em>, you’ve dealt with upstart.</p>

<h3>Failure conditions</h3>

<p><a href="http://www.tuxradar.com/content/how-fix-linux-boot-problems"><img alt="Boot failure conditions" src="http://johntron.com/wp-content/uploads/2013/01/LXF100.tut_bootfail.diagram.png" width="404" height="483" /></a></p>

<h3>BIOS/MBR vs. (U)EFI/GPT</h3>

<p>Manufacturers and OS distributions are currently transitioning from BIOS and MBR’s to UEFI and GPT’s. BIOS and MBR’s were not built with 2TB hard drives in mind – similarly to 32-bit systems with lots of RAM, they simply cannot access (address) these large drives because they simply don’t have the vocabulary. <a href="http://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface" target="_blank">The Unified Extensible Firmware Interface</a> (previously known as simply EFI, but people united and we now call it UEFI) and GUID Partition Table (GPT) format were created to address this limitation (and others).</p>

<p>UEFI is a protocol describing how hardware and software should communicate. This means a (U)EFI motherboard will require a UEFI image (bootlooader) and OS that understands UEFI (Windows does). Older hardware can be made to use UEFI images by essentially bootstrapping UEFI from BIOS (think BIOS -> MBR -> UEFI). Conversely, many UEFI images include legacy support for BIOS (Windows 7 for instance), so they can work on older hardware.</p>

<p>The specification for the GPT format is a subset of the UEFI specification. While GPT and UEFI are closely intertwined, hardware and software created during the BIOS-to-UEFI transitory period often provides legacy support for BIOS and MBR. When building a system, be sure to check if your OS will work with your motherboard. Some BIOS motherboards can be upgraded (by flashing the ROM) to use UEFI, and some include support for both UEFI and BIOS, this is not always the case (and will probably not be the case in the near future). If your motherboard cannot do UEFI, make sure your OS includes legacy support for BIOS. Similarly, even though BIOS was designed to use MBR’s and UEFI was designed for GPT’s, BIOS systems can be configured to use the MBR to bootstrap EFI/GPT – this does not mean that UEFI systems can use GPT to bootstrap BIOS/MBR!</p>

<h3>Does it have to be so confusing? {#confusing}</h3>

<p>I was struck by the complexity of the bootup process was and wondered why it had been designed this way. I understand how transistors work, how they are combined to create a binary system, how binary operations are organized into an instruction set, how an instruction set is used by a compiler to provide high-level programming languages, and how high-level programming languages are used to describe tasks for the hardware to perform. Still, the boot process seemed like a mystical magical thing that ends with a command prompt when things go well and the impression of a keyboard on my forehead when things go wrong.</p>

<p>I think part of the reason it’s so mystical is because there’s so many moving pieces. Transistors, binary, and instruction sets are each pretty simple, so why was the bootup process designed to be so complex? The short answer is it wasn’t (designed). The complexity is the result of shoehorning newer functionality into an old design. I wonder if early systems had something like GRUB and also how hard they to recover from disaster. Anyone that’s ever used LILO will understand how powerful today’s bootloaders and kernels are. While this extra complexity is confusing it provides certain niceties like allowing us to load GRUB modules at runtime so we can access disparate filesystems.</p>

<p>Interestingly, it is possible to compile a very small version of the Linux kernel that will fit in the MBR and act as the bootloader. While this eliminates the need for GRUB altogether, this type of setup will probably not include the disaster recovery that GRUB provides, and a more robust system would probably just use UEFI hardware and a recent version of the Linux kernel.</p>

<p>In the future systems will be even more powerful but also more intuitive. BIOS and MBR are currently deprecated and are being replaced by UEFI and GPT which are much simpler to setup and provide more functionality. In the future boot sectors will not be required at the beginning of disks. While chainloading (using a bootloader to bootstrap another bootloader) will still be possible, it won’t be necessary, so GRUB initialization may become a single-stage process. Even though GRUB now provides UEFI support for newer hardware,  <a href="https://wiki.archlinux.org/index.php/UEFI_Bootloaders#Linux_Kernel_EFISTUB" target="_blank">the Linux kernel has had native UEFI support since version 3.3</a> (Ubuntu 12.10 comes with version 3.5). Someday, GRUB will probably be obsolete; however, it looks like <a href="http://arstechnica.com/information-technology/2012/10/linux-foundation-to-offer-signed-solution-for-uefi-secure-boot-conundrum/" target="_blank">reality it will even more complex thanks to Microsoft</a>.</p>

<h3>Useful links</h3>

<ul>
<li><a href="http://www.ibm.com/developerworks/library/l-linuxboot/index.html" target="_blank">Inside the Linux boot process</a></li>
<li><a href="http://en.wikipedia.org/wiki/Linux_startup_process" target="_blank">Linux startup process</a></li>
<li><a href="http://www.debian.org/doc/manuals/debian-reference/ch03.en.html" target="_blank">The system initialization</a></li>
<li><a href="http://wiki.debian.org/BootProcess" target="_blank">BootProcess</a></li>
<li><a href="http://www.tuxradar.com/content/how-fix-linux-boot-problems" target="_blank">How to fix Linux boot problems</a></li>
<li><a href="http://ubuntuforums.org/showthread.php?t=1599293" target="_blank">HOWTO: Boot &amp; Install Ubuntu from the Grub Rescue Prompt</a></li>
<li><a href="http://askubuntu.com/questions/84501/how-can-i-change-convert-a-ubuntu-mbr-drive-to-a-gpt-and-make-ubuntu-boot-from" target="_blank">How can I change/convert a Ubuntu MBR drive to a GPT, and make Ubuntu boot from EFI?</a></li>
<li><a href="http://www.burnedin.com/article/gpt-vs-mbr-explained" target="_blank">GPT vs MBR – GPT Explained</a></li>
<li><a href="http://www.kernel.org/doc/Documentation/kernel-parameters.txt" target="_blank">Kernel Parameters</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
