<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: mobile | Johntron.com]]></title>
  <link href="http://johntron.github.com/blog/categories/mobile/atom.xml" rel="self"/>
  <link href="http://johntron.github.com/"/>
  <updated>2013-01-31T08:10:55-06:00</updated>
  <id>http://johntron.github.com/</id>
  <author>
    <name><![CDATA[John Syrinek]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to root a Kindle Fire on OS X]]></title>
    <link href="http://johntron.github.com/mobile/how-to-root-a-kindle-fire-on-os-x/"/>
    <updated>2012-02-20T00:00:00-06:00</updated>
    <id>http://johntron.github.com/mobile/how-to-root-a-kindle-fire-on-os-x</id>
    <content type="html"><![CDATA[<ol>
<li>Download and extract the <a href="http://developer.android.com/sdk/index.html">Android SDK</a></li>
<li>Download <a href="http://forum.xda-developers.com/showthread.php?t=1410223">BurritoRoot3.apk</a></li>
<li>Download and extract <a href="http://wiki.cyanogenmod.com/index.php?title=Latest_Version">Google Apps for Android</a>. Scroll to the bottom of the page and there’s a download link listed next to latest version of CyanogenMod under “Google Apps”</li>
<li>Download <a href="http://munday.ws/2011/12/kindle-fire-market-opener/">Kindle Fire Market Opener</a></li>
<li>Open <em><extracted Android SDK folder>/tools/android</em> by double-clicking or launching with Terminal</li>
<li>Install Android SDK Platform-tools and (not sure if it’s required) Android 2.3.3/SDK Platform</li>
<li>Connect your Kindle to your Mac with USB cable.</li>
<li>In Terminal, run:<br/>
[bash]echo “0×1949″ >> ~/.android/adb_usb.ini # Adds Amazon vendor ID to list of allowed USB devices<br/>
cd <extracted Android SDK folder>/platform-tools<br/>
./adb start-server # Allows us to execute commands on the device<br/>
./adb devices # This should show one device<br/>
./adb shell chmod 777 /data/local/tmp # Need to be able to write to tmp folder<br/>
./adb install <path to BurritoRoot3.apk><br/>
[/bash]</li>
<li>Launch BurritoRoot3 on your Kindle</li>
<li>In Terminal run:<br/>
[bash]<br/>
./adb shell /data/local/tmp/BurritoRoot3.bin –root # Roots device<br/>
./adb shell /data/local/tmp/BurritoRoot3.bin –install # Installs Superuser app<br/>
./adb install <path to Google Apps>/system/app/GoogleServicesFramework.apk # Dependencies<br/>
./adb push <path to GApps>/system/app/Vending.apk /system/app/Vending.apk # Marketplace<br/>
./adb shell chmod 644 /system/app/Vending.apk # Sets permissions correctly<br/>
./adb install <path to Market Opener>/MarketOpener.apk # Puts Marketplace on Carousel

<h1>May need to use <a href="http://www.amazon.com/Xian-Geek-File-Expert/dp/B004VMY62Q/ref=cm_cr_pr_product_top">File Expert</a> to install /system/App/Vending.apk</h1>

<p>[/bash]</p></li>
<li>Restart your Fire, then launch the Marketplace app and follow the instructions</li>
</ol>


<p> </p>

<p style="padding: 1em; background-color: #f2c879; border: 1px solid gray;">
  Is this outdated? Leave me a comment so I know!
</p>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Decoupling development and production code]]></title>
    <link href="http://johntron.github.com/advice/decoupling-development-and-production/"/>
    <updated>2009-03-09T00:00:00-05:00</updated>
    <id>http://johntron.github.com/advice/decoupling-development-and-production</id>
    <content type="html"><![CDATA[<p>I use Subversion to deploy web applications using a simple <code>svn update</code> command on a production server. This is really convenient, but something has always bothered me. Domain names for production servers are never the same as the development servers. This is true regardless of whether you use PHP, Python, Ruby, or something else. For this reason, deploying is never as easy as typing <code>svn update</code>.</p>

<p>This specific problem is fairly new to computer science, because server-side scripting languages are relatively new in the whole scheme of things. I’ve done some research, and I’ve documented the most elegant solution I could come up with to minimize the possibility of human error from the deployment process. As a professional web developer, this method has saved me many headaches and lots of man hours.</p>

<p class="list_header">
  Here are the highlights:
</p>


<ul>
<li>Machine independent</li>
<li>Language independent</li>
<li>Easy to deploy</li>
<li>Easy to setup</li>
<li>Maintenance free (no tweaking during the deployment phase)</li>
<li>Standard (available on most systems)</li>
</ul>


<p>This system uses <code>m4</code> and <code>make</code>. <code>m4</code> is tool used to generate code from macros (among other things). Using m4 means we can do things similar to preprocessor directives in C languages. Make is a build tool used for generating non-source files from source files. Using make means we can generate one set of files for a development environment, and one set of files for a production environment. This system is very common, and has been around for years, so there should be plenty of documentation out there.</p>

<p class="list_header">
  After setting up this build system, deployment would work like this:
</p>


<ol>
<li>From a development server, commit changes to a Subversion repository</li>
<li>From a production server, update a working copy</li>
<li>Run `make`</li>
</ol>


<p>I will not discuss Subversion, as this is covered elsewhere. I’ll assume you know this, so let’s get started by creating an m4 file.</p>

<h3>m4 as a Preprocessor</h3>

<p>Ideally, all of the machine-specific settings should be stored in a single file. This is often called a config file or a settings file. In my case, the file is named “settings.py”, because I’m writing some software using Django. To decouple the machine-specific code, I will need to be able to write macros in settings.py. To do this, I rename the file to “settings.py.m4″. The m4 extension is used to denote files that should be processed with m4 (clearly). After renaming the file, I can use whatever macros I want. The most useful macro is a simple <code>if…else…</code> function called <code>ifdef()</code>.</p>

<p class="list_header">
  The most common <code>ifdef()</code> macro will look like this:
</p>


<pre><code>ifdef(`debug', `True', `False')
</code></pre>

<p>m4 would replace this statement with <code>True</code> or <code>False</code> based on whether or not <code>debug</code> is defined. The true power of this is made apparent when you start assigning URLs to variable.</p>

<p class="list_header">
  For instance, imagine a file that contains this line of code:
</p>


<pre><code>DEBUG = True
</code></pre>

<p>This <code>DEBUG</code> variable could be used to control output and logging. Clearly, debug should never be enabled on a production server (gross). So how would you account for two different environments? The most straightforward solution would be to manually edit this file after each <code>svn update</code> or perhaps have Subversion ignore this file. By manually editing this file each time, you are assuming you’ll remember to do this. By ignoring this file from Subversion, you’re throwing out all the benefits of version control.</p>

<p class="list_header">
  So here is where m4 comes in. Replace the line of code listed above with this:
</p>


<pre><code>DEBUG = ifdef(`debug', `True', `False')
</code></pre>

<p class="list_header">
  Notice that <code>debug</code> is not defined yet (not to be confused with <code>DEBUG</code>). If we were to run m4 on this file, this line would end up looking like this:
</p>


<pre><code>DEBUG = False
</code></pre>

<p class="list_header">
  So now we just need to define “debug” at a higher level. The best place for this is at the command line. With m4, you can define variables on the command line. Use the <code>-D</code> flag to accomplish this. In our case we would type something like this (from the command line): <code>m4 -D debug settings.py.m4</code>. After hitting enter, you would see the entire settings.py.m4 file output to the shell. If you look carefully, you should see the following:
</p>


<pre><code>DEBUG = True
</code></pre>

<p class="list_header">
  Try running the same command again, but without the <code>-D debug </code> this time. You should see:
</p>


<pre><code>DEBUG = False
</code></pre>

<p>When you’re done learning about m4, run the command one last time, but this time save the output to a file by running this command: <code>m4 -D debug settings.py.m4 &gt; settings.py</code> Now we’ve decoupled our machine-specific code and can control it from the command line. The last step is to make things a little easier to remember. <code>make</code> is great for this, because it allows us to create build targets.</p>

<h3>Deploying web software with make</h3>

<p>A target is simply a final copy of an application. In our case, we will have a development target and a production target. Begin simplifying things by creating a file name “Makefile” in the highest level directory of your source code. This file is used by make to determine what needs to be done for any given build target. The syntax of this file is pretty simple.</p>

<p class="list_header">
  My Makefile looks like this:
</p>


<pre><code>live:
    m4 placethings/settings.py.m4 &gt; placethings/settings.py

development:
    m4 -D debug placethings/settings.py.m4 &gt; placethings/settings.py
</code></pre>

<p>This file defines two targets: <code>live</code> and <code>development</code>. To build a target, we type: <code>make [target]</code>. Make assumes the first target is the default, so we can just type <code>make</code>, and “settings.py.m4″ would be processed for a production environment and saved to “settings.py”. Alternatively, we could type <code>make development</code> and “settings.py.m4″ would be processed for a development environment and saved to “settings.py”.</p>

<p>The last step is to put these files under version control along with everything else ( using <code>svn add</code>). If you wanted to, you could even go one step further and add <code>svn update</code> to your Makefile. There are advantages and disadvantes to this. I prefer not to do this, because anything that happens during the update process can affect the rest of the build process.</p>

<p>Clearly, I’m passionate about removing the possiblity of human error. Some might say this is obsessive, but I say it’s what makes good software great. Now, instead of potentially spewing code traces at your users without realizing it everytime you change your code, you just have to make sure your build process works next time you use an <code>ifdef()</code> in your settings.py.m4 file. This is much easier to do than trying to trigger an exception on the production server.</p>
]]></content>
  </entry>
  
</feed>
